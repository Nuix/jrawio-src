/***********************************************************************************************************************
 *
 * jrawio - a Java(TM) Image I/O SPI Provider for Camera Raw files
 * Copyright (C) 2003-2011 by Tidalwave s.a.s.
 *
 ***********************************************************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 *
 ***********************************************************************************************************************
 *
 * WWW: http://jrawio.rawdarkroom.org
 * SCM: https://kenai.com/hg/jrawio~src
 *
 **********************************************************************************************************************/
package it.tidalwave.imageio.nef;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.IOException;
import javax.imageio.spi.ImageReaderSpi;
import it.tidalwave.imageio.tiff.IFD;
import it.tidalwave.imageio.tiff.TIFFImageReaderSupport;
import it.tidalwave.imageio.tiff.TIFFMetadataSupport;
import it.tidalwave.imageio.util.Logger;
import static it.tidalwave.imageio.nef.NEFRasterReader.CompressionType.*;

/***********************************************************************************************************************
 *
 * @author  Fabrizio Giudici
 * @version $Id$
 *
 **********************************************************************************************************************/
public class NEFImageReader extends TIFFImageReaderSupport
  {
    private final static String CLASS = NEFImageReader.class.getName();
    private final static Logger logger = Logger.getLogger(CLASS);

    private boolean isNDF = false;

    /*******************************************************************************************************************
     *
     ******************************************************************************************************************/
    protected NEFImageReader (@Nonnull final ImageReaderSpi originatingProvider, 
                              @CheckForNull final Object extension)
      {
        super(originatingProvider, NikonMakerNote3.class, NEFMetadata.class);
        headerProcessor = new NEFHeaderProcessor();
      }

    /*******************************************************************************************************************
     *
     * @inheritDoc
     * 
     * Loads a NEF image. This method is able to take care of:
     * 
     * <ol>
     * <li>regular RAW files;</li>
     * <li>"dust sample" files (.NDF);</li>
     * <li>JPEG images embedded in NEF (can be generated by Nikon Capture Editor)</li>
     * </ol>
     * 
     * RAW and dust samples are delegated to loadRAWImage(), while JPEGs are 
     * delegated to loadEmbeddedImage(). 
     * 
     *
     * @param  imageIndex   the imageIndex of the image to load
     * @return              the image
     * @throws IOException  if an I/O error occurs
     *
     ******************************************************************************************************************/
    @Override
    protected BufferedImage loadImage (@Nonnull final int imageIndex) 
      throws IOException
      {
        logger.fine("loadImage(%d) - iis: %s", imageIndex, iis);
        checkImageIndex(imageIndex);
        ensureMetadataIsLoaded(imageIndex);

        IFD rasterIFD = ((TIFFMetadataSupport)metadata).getRasterIFD();
        BufferedImage image;
        IFD.Compression compression = null;

        if ((rasterIFD != null) && rasterIFD.isCompressionAvailable()) // NDF doesn't have it
          {
            compression = rasterIFD.getCompression();
          }

        if (compression == IFD.Compression.OJPEG) // TODO: check if you can move this to RAWImageReaderSupport
          {
            int offset = rasterIFD.getJPEGInterchangeFormat();
            int length = rasterIFD.getJPEGInterchangeFormatLength();
            image = loadEmbeddedImage(iis, offset + headerProcessor.getOffset(), length);
          }

        else
          {
            image = loadRAWImage();
          }

        logger.fine(">>>> loadImage() completed ok, returning " + image);

        return image;
      }

    /*******************************************************************************************************************
     *
     * @inheritDoc
     * 
     ******************************************************************************************************************/
    @Nonnull
    protected WritableRaster loadRAWRaster() 
      throws IOException
      {
        logger.fine("loadRAWRaster() - iis: %s", iis);
        final IFD primaryIFD = ((IFD)primaryDirectory);
        final IFD rasterIFD = ((TIFFMetadataSupport)metadata).getRasterIFD();
        final IFD exifIFD = ((TIFFMetadataSupport)metadata).getExifIFD();
        final IFD thumbnailIFD = ((TIFFMetadataSupport)metadata).getThumbnailHelper()[0].getIFD();
        final NikonMakerNote3 nikonMakerNote = (NikonMakerNote3)makerNote;

        final long time = System.currentTimeMillis();
        final int offset = (!isNDF) ? rasterIFD.getStripOffsets() : thumbnailIFD.getJPEGInterchangeFormat()
            + thumbnailIFD.getJPEGInterchangeFormatLength(); // FIXME: just a guess
        iis.seek(offset); 
        
        final int bitsPerSample = (!isNDF) ? rasterIFD.getBitsPerSample()[0] : exifIFD.getCompressedBitsPerPixel().intValue();
        final String model = primaryIFD.getModel();
        final NEFRasterReader rasterReader = NEFRasterReader.getInstance(model, isNDF);
        final int width = (!isNDF) ? rasterIFD.getImageWidth() : exifIFD.getPixelXDimension();
        final int height = (!isNDF) ? rasterIFD.getImageLength() : exifIFD.getPixelYDimension();
        initializeRasterReader(width, height, bitsPerSample, rasterReader);

        if (nikonMakerNote.isCompressionDataAvailable())
          {
            final NEFCompressionData compressionDataObject = nikonMakerNote.getCompressionDataObject();
            // FIXME: encapsulate a NEFCompressionData.getCompressionType()
            rasterReader.setCompressionType(((compressionDataObject.getVersion() & 0xff00) == 0x4600) ? LOSSLESS : LOSSY);
            rasterReader.setLinearizationTable(compressionDataObject.getExpandedValues(bitsPerSample));
            rasterReader.setVPredictor(nikonMakerNote.getCompressionDataObject().getVPredictor());
          }

        logger.finest(">>>> using rasterReader: %s", rasterReader);
        WritableRaster raster = rasterReader.loadRaster(iis, this);
        logger.finer(">>>> loadRAWRaster() completed ok in %d msec.", (System.currentTimeMillis() - time));

        return raster;
      }

    /*******************************************************************************************************************
     * 
     * @inheritDoc
     * 
     ******************************************************************************************************************/
    @Override
    protected void processMetadata() 
      throws IOException
      {
        iis.setBaseOffset(headerProcessor.getOffset());
        isNDF = iis.getBaseOffset() != 0;//FIXME: do it better
        super.processMetadata();
      }
  }
